{"type":"auditAdvisory","data":{"resolution":{"id":1111755,"path":"karma>body-parser>qs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.13.0","paths":["karma>body-parser>qs"]}],"found_by":null,"deleted":null,"references":"- https://github.com/ljharb/qs/security/advisories/GHSA-6rw7-vpxm-498p\n- https://nvd.nist.gov/vuln/detail/CVE-2025-15284\n- https://github.com/ljharb/qs/commit/3086902ecf7f088d0d1803887643ac6c03d415b9\n- https://github.com/advisories/GHSA-6rw7-vpxm-498p","created":"2025-12-30T21:02:54.000Z","id":1111755,"npm_advisory_id":null,"overview":"### Summary\n\nThe `arrayLimit` option in qs does not enforce limits for bracket notation (`a[]=1&a[]=2`), allowing attackers to cause denial-of-service via memory exhaustion. Applications using `arrayLimit` for DoS protection are vulnerable.\n\n### Details\n\nThe `arrayLimit` option only checks limits for indexed notation (`a[0]=1&a[1]=2`) but completely bypasses it for bracket notation (`a[]=1&a[]=2`).\n\n**Vulnerable code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Working code** (`lib/parse.js:175`):\n```javascript\nelse if (index <= options.arrayLimit) {  // Limit checked here\n    obj = [];\n    obj[index] = leaf;\n}\n```\n\nThe bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays.\n\n### PoC\n\n**Test 1 - Basic bypass:**\n```bash\nnpm install qs\n```\n\n```javascript\nconst qs = require('qs');\nconst result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 });\nconsole.log(result.a.length);  // Output: 6 (should be max 5)\n```\n\n**Test 2 - DoS demonstration:**\n```javascript\nconst qs = require('qs');\nconst attack = 'a[]=' + Array(10000).fill('x').join('&a[]=');\nconst result = qs.parse(attack, { arrayLimit: 100 });\nconsole.log(result.a.length);  // Output: 10000 (should be max 100)\n```\n\n**Configuration:**\n- `arrayLimit: 5` (test 1) or `arrayLimit: 100` (test 2)\n- Use bracket notation: `a[]=value` (not indexed `a[0]=value`)\n\n### Impact\n\nDenial of Service via memory exhaustion. Affects applications using `qs.parse()` with user-controlled input and `arrayLimit` for protection.\n\n**Attack scenario:**\n1. Attacker sends HTTP request: `GET /api/search?filters[]=x&filters[]=x&...&filters[]=x` (100,000+ times)\n2. Application parses with `qs.parse(query, { arrayLimit: 100 })`\n3. qs ignores limit, parses all 100,000 elements into array\n4. Server memory exhausted → application crashes or becomes unresponsive\n5. Service unavailable for all users\n\n**Real-world impact:**\n- Single malicious request can crash server\n- No authentication required\n- Easy to automate and scale\n- Affects any endpoint parsing query strings with bracket notation\n\n### Suggested Fix\n\nAdd `arrayLimit` validation to the bracket notation handler. The code already calculates `currentArrayLength` at line 147-151, but it's not used in the bracket notation handler at line 159.\n\n**Current code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n        ? []\n        : utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Fixed code**:\n```javascript\nif (root === '[]' && options.parseArrays) {\n    // Use currentArrayLength already calculated at line 147-151\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n    \n    // If limit exceeded and not throwing, convert to object (consistent with indexed notation behavior)\n    if (currentArrayLength >= options.arrayLimit) {\n        obj = options.plainObjects ? { __proto__: null } : {};\n        obj[currentArrayLength] = leaf;\n    } else {\n        obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n            ? []\n            : utils.combine([], leaf);\n    }\n}\n```\n\nThis makes bracket notation behaviour consistent with indexed notation, enforcing `arrayLimit` and converting to object when limit is exceeded (per README documentation).","reported_by":null,"title":"qs's arrayLimit bypass in its bracket notation allows DoS via memory exhaustion","metadata":null,"cves":["CVE-2025-15284"],"access":"public","severity":"high","module_name":"qs","vulnerable_versions":"<6.14.1","github_advisory_id":"GHSA-6rw7-vpxm-498p","recommendation":"Upgrade to version 6.14.1 or later","patched_versions":">=6.14.1","updated":"2025-12-30T21:02:55.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-20"],"url":"https://github.com/advisories/GHSA-6rw7-vpxm-498p"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112954,"path":"@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"5.0.0","paths":["@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion"]}],"found_by":null,"deleted":null,"references":"- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25547\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2","created":"2026-02-03T19:41:15.000Z","id":1112954,"npm_advisory_id":null,"overview":"### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library","reported_by":null,"title":"@isaacs/brace-expansion has Uncontrolled Resource Consumption","metadata":null,"cves":["CVE-2026-25547"],"access":"public","severity":"high","module_name":"@isaacs/brace-expansion","vulnerable_versions":"<=5.0.0","github_advisory_id":"GHSA-7h2j-956f-4vf2","recommendation":"Upgrade to version 5.0.1 or later","patched_versions":">=5.0.1","updated":"2026-02-05T00:36:55.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-1333"],"url":"https://github.com/advisories/GHSA-7h2j-956f-4vf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112954,"path":"@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"5.0.0","paths":["@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion"]}],"found_by":null,"deleted":null,"references":"- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25547\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2","created":"2026-02-03T19:41:15.000Z","id":1112954,"npm_advisory_id":null,"overview":"### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library","reported_by":null,"title":"@isaacs/brace-expansion has Uncontrolled Resource Consumption","metadata":null,"cves":["CVE-2026-25547"],"access":"public","severity":"high","module_name":"@isaacs/brace-expansion","vulnerable_versions":"<=5.0.0","github_advisory_id":"GHSA-7h2j-956f-4vf2","recommendation":"Upgrade to version 5.0.1 or later","patched_versions":">=5.0.1","updated":"2026-02-05T00:36:55.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-1333"],"url":"https://github.com/advisories/GHSA-7h2j-956f-4vf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112954,"path":"@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"5.0.0","paths":["@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion"]}],"found_by":null,"deleted":null,"references":"- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25547\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2","created":"2026-02-03T19:41:15.000Z","id":1112954,"npm_advisory_id":null,"overview":"### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library","reported_by":null,"title":"@isaacs/brace-expansion has Uncontrolled Resource Consumption","metadata":null,"cves":["CVE-2026-25547"],"access":"public","severity":"high","module_name":"@isaacs/brace-expansion","vulnerable_versions":"<=5.0.0","github_advisory_id":"GHSA-7h2j-956f-4vf2","recommendation":"Upgrade to version 5.0.1 or later","patched_versions":">=5.0.1","updated":"2026-02-05T00:36:55.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-1333"],"url":"https://github.com/advisories/GHSA-7h2j-956f-4vf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112954,"path":"@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"5.0.0","paths":["@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion"]}],"found_by":null,"deleted":null,"references":"- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25547\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2","created":"2026-02-03T19:41:15.000Z","id":1112954,"npm_advisory_id":null,"overview":"### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library","reported_by":null,"title":"@isaacs/brace-expansion has Uncontrolled Resource Consumption","metadata":null,"cves":["CVE-2026-25547"],"access":"public","severity":"high","module_name":"@isaacs/brace-expansion","vulnerable_versions":"<=5.0.0","github_advisory_id":"GHSA-7h2j-956f-4vf2","recommendation":"Upgrade to version 5.0.1 or later","patched_versions":">=5.0.1","updated":"2026-02-05T00:36:55.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-1333"],"url":"https://github.com/advisories/GHSA-7h2j-956f-4vf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112954,"path":"@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"5.0.0","paths":["@angular/cli>pacote>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>@npmcli/package-json>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>npm-registry-fetch>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>@npmcli/run-script>node-gyp>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion","@angular/cli>pacote>sigstore>@sigstore/tuf>tuf-js>make-fetch-happen>cacache>glob>minimatch>@isaacs/brace-expansion"]}],"found_by":null,"deleted":null,"references":"- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25547\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2","created":"2026-02-03T19:41:15.000Z","id":1112954,"npm_advisory_id":null,"overview":"### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library","reported_by":null,"title":"@isaacs/brace-expansion has Uncontrolled Resource Consumption","metadata":null,"cves":["CVE-2026-25547"],"access":"public","severity":"high","module_name":"@isaacs/brace-expansion","vulnerable_versions":"<=5.0.0","github_advisory_id":"GHSA-7h2j-956f-4vf2","recommendation":"Upgrade to version 5.0.1 or later","patched_versions":">=5.0.1","updated":"2026-02-05T00:36:55.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-1333"],"url":"https://github.com/advisories/GHSA-7h2j-956f-4vf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112952,"path":"@angular/cli>@modelcontextprotocol/sdk","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.25.2","paths":["@angular/cli>@modelcontextprotocol/sdk"]}],"found_by":null,"deleted":null,"references":"- https://github.com/modelcontextprotocol/typescript-sdk/security/advisories/GHSA-345p-7cg4-v4c7\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/204\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/243\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25536\n- https://github.com/advisories/GHSA-345p-7cg4-v4c7","created":"2026-02-04T20:04:16.000Z","id":1112952,"npm_advisory_id":null,"overview":"### Summary\n\nCross-client response data leak when a single `McpServer`/`Server` and transport instance is reused across multiple client connections, most commonly in stateless `StreamableHTTPServerTransport` deployments.\n\n### Impact\n\n**Who is affected:** Any MCP server deployment using the TypeScript SDK where a single `McpServer` (or `Server`) instance is shared across multiple concurrent client connections. This is most likely in stateless mode (no `sessionIdGenerator`), where the natural but incorrect pattern is to create one server and transport and handle all requests through it. Stateful mode is also affected if the server instance is improperly shared across sessions, though this misconfiguration is less common since the stateful pattern naturally encourages per-session instances.\n\n**What happens:** When two or more MCP clients send requests concurrently through a shared server instance, JSON-RPC message ID collisions cause responses to be routed to the wrong client's HTTP connection. Client A can receive response data intended for Client B, and vice versa, even when authorization was correctly enforced on each individual request.\n\nThe MCP SDK's client generates message IDs using a simple incrementing counter starting at 0. When two clients connect to the same server instance, they produce identical message IDs, causing the transport's internal request-to-stream mapping to overwrite one client's entry with another's — routing responses to the wrong HTTP connection.\n\n**Conditions for exploitation:**\n- The server reuses a single `McpServer`/`Server` instance across requests or sessions (rather than creating fresh instances per request/session)\n- Two or more clients connect concurrently\n- Clients generate overlapping JSON-RPC message IDs (virtually guaranteed since the SDK's client uses an incrementing counter starting at 0)\n\n**Not affected:**\n- Stateful servers that create a new `McpServer` + transport per session (the typical and recommended stateful pattern)\n- Stateless servers that create a new `McpServer` + transport per request\n- Single-client environments (e.g., local development with one IDE)\n\n### Patches\n\nThe fix adds runtime guards that turn silent data misrouting into immediate, actionable errors:\n\n1. `Protocol.connect()` now throws if the protocol is already connected to a transport, preventing silent transport overwriting across both stateful and stateless modes\n2. Stateless `StreamableHTTPServerTransport.handleRequest()` now throws if called more than once, enforcing one-request-per-transport in stateless mode\n\nServers that were incorrectly reusing instances will now receive a clear error message directing them to create separate instances per connection.\n\n### Workarounds\n\nIf projects cannot upgrade immediately, ensure the server creates fresh `McpServer` and transport instances for each request (stateless) or session (stateful):\n\n```typescript\n// Stateless mode: create new server + transport per request\napp.post('/mcp', async (req, res) => {\n  const server = new McpServer({ name: 'my-server', version: '1.0.0' });\n  // ... register tools, resources, etc.\n  const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: undefined });\n  await server.connect(transport);\n  await transport.handleRequest(req, res);\n});\n\n// Stateful mode: create new server + transport per session\nconst sessions = new Map();\napp.post('/mcp', async (req, res) => {\n  const sessionId = req.headers['mcp-session-id'];\n  if (sessions.has(sessionId)) {\n    await sessions.get(sessionId).transport.handleRequest(req, res);\n  } else {\n    const server = new McpServer({ name: 'my-server', version: '1.0.0' });\n    // ... register tools, resources, etc.\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () => randomUUID()\n    });\n    await server.connect(transport);\n    sessions.set(transport.sessionId, { server, transport });\n    await transport.handleRequest(req, res);\n  }\n});\n```\n\n### Resources\n\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/204\n- https://github.com/modelcontextprotocol/typescript-sdk/issues/243","reported_by":null,"title":"@modelcontextprotocol/sdk has cross-client data leak via shared server/transport instance reuse","metadata":null,"cves":["CVE-2026-25536"],"access":"public","severity":"high","module_name":"@modelcontextprotocol/sdk","vulnerable_versions":">=1.10.0 <=1.25.3","github_advisory_id":"GHSA-345p-7cg4-v4c7","recommendation":"Upgrade to version 1.26.0 or later","patched_versions":">=1.26.0","updated":"2026-02-05T00:35:15.000Z","cvss":{"score":7.1,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N"},"cwe":["CWE-362"],"url":"https://github.com/advisories/GHSA-345p-7cg4-v4c7"}}}
{"type":"auditSummary","data":{"vulnerabilities":{"info":0,"low":0,"moderate":0,"high":7,"critical":0},"dependencies":1206,"devDependencies":0,"optionalDependencies":0,"totalDependencies":1206}}
